{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///D:/CS%20Y3/FYP/FWMS/FWMS/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\"\n\n/**\n * Database client singleton.\n * Prevents creating multiple Prisma clients during development hot-reloads.\n */\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\n// Create or reuse existing Prisma client\nexport const db =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    // Log queries in development for debugging\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  })\n\n// Store in global to reuse across hot-reloads (development only)\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = db\n\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;CAGC,GACD,MAAM,kBAAkB;AAKjB,MAAM,KACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,2CAA2C;IAC3C,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEF,iEAAiE;AACjE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///D:/CS%20Y3/FYP/FWMS/FWMS/lib/auth.ts"],"sourcesContent":["import { NextAuthOptions } from \"next-auth\"\nimport CredentialsProvider from \"next-auth/providers/credentials\"\nimport { db } from \"./db\"\nimport bcrypt from \"bcryptjs\"\n\n/**\n * NextAuth configuration for authentication.\n * Uses credentials provider to authenticate users from the database.\n */\nexport const authOptions: NextAuthOptions = {\n  providers: [\n    CredentialsProvider({\n      name: \"Credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      /**\n       * Authorizes user by checking email and password against database.\n       * Returns user object if valid, null otherwise.\n       */\n      async authorize(credentials) {\n        // Validate credentials\n        if (!credentials?.email || !credentials?.password) {\n          return null\n        }\n\n        // Find user in database\n        const user = await db.user.findUnique({\n          where: {\n            email: credentials.email,\n          },\n          include: {\n            business: true,\n          },\n        })\n\n        if (!user) {\n          return null\n        }\n\n        // Verify password using bcrypt\n        const isPasswordValid = await bcrypt.compare(credentials.password, user.password)\n\n        if (!isPasswordValid) {\n          return null\n        }\n\n        // Return user data for session\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          role: user.role,\n          businessId: user.businessId,\n          business: user.business,\n        }\n      },\n    }),\n  ],\n  session: {\n    strategy: \"jwt\", // Use JWT for session storage\n  },\n  pages: {\n    signIn: \"/login\", // Custom login page\n    signOut: \"/\", // Redirect to home after logout\n  },\n  callbacks: {\n    /**\n     * Adds user data to JWT token when user signs in.\n     */\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id\n        token.role = user.role\n        token.businessId = user.businessId\n        token.business = user.business\n      }\n      return token\n    },\n    /**\n     * Adds user data from token to session object.\n     */\n    async session({ session, token }) {\n      if (session.user) {\n        session.user.id = token.id as string\n        session.user.role = token.role as string\n        session.user.businessId = token.businessId as string | null\n        session.user.business = token.business as any\n      }\n      return session\n    },\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n}\n\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAMO,MAAM,cAA+B;IAC1C,WAAW;QACT,IAAA,6KAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA;;;OAGC,GACD,MAAM,WAAU,WAAW;gBACzB,uBAAuB;gBACvB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,wBAAwB;gBACxB,MAAM,OAAO,MAAM,yHAAE,CAAC,IAAI,CAAC,UAAU,CAAC;oBACpC,OAAO;wBACL,OAAO,YAAY,KAAK;oBAC1B;oBACA,SAAS;wBACP,UAAU;oBACZ;gBACF;gBAEA,IAAI,CAAC,MAAM;oBACT,OAAO;gBACT;gBAEA,+BAA+B;gBAC/B,MAAM,kBAAkB,MAAM,sJAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ;gBAEhF,IAAI,CAAC,iBAAiB;oBACpB,OAAO;gBACT;gBAEA,+BAA+B;gBAC/B,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,MAAM,KAAK,IAAI;oBACf,YAAY,KAAK,UAAU;oBAC3B,UAAU,KAAK,QAAQ;gBACzB;YACF;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,OAAO;QACL,QAAQ;QACR,SAAS;IACX;IACA,WAAW;QACT;;KAEC,GACD,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,KAAK,IAAI;gBACtB,MAAM,UAAU,GAAG,KAAK,UAAU;gBAClC,MAAM,QAAQ,GAAG,KAAK,QAAQ;YAChC;YACA,OAAO;QACT;QACA;;KAEC,GACD,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;gBAC9B,QAAQ,IAAI,CAAC,UAAU,GAAG,MAAM,UAAU;gBAC1C,QAAQ,IAAI,CAAC,QAAQ,GAAG,MAAM,QAAQ;YACxC;YACA,OAAO;QACT;IACF;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC","debugId":null}},
    {"offset": {"line": 234, "column": 0}, "map": {"version":3,"sources":["file:///D:/CS%20Y3/FYP/FWMS/FWMS/app/api/waste/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { getServerSession } from \"next-auth\"\nimport { authOptions } from \"@/lib/auth\"\nimport { db } from \"@/lib/db\"\nimport { z } from \"zod\"\n\nconst wasteEntrySchema = z.object({\n  date: z.string().optional(),\n  wasteType: z.enum([\"EDIBLE\", \"COFFEE_GROUNDS\", \"ORGANIC\", \"EXPIRED\", \"RECYCLABLE\", \"PLATE_WASTE\"]),\n  subType: z.string().optional(),\n  quantity: z.number().positive(),\n  actionType: z.enum([\"DONATE\", \"COMPOST\", \"FARM\", \"REUSE\", \"DROPPED\"]),\n  destination: z.string().optional(),\n  expiryDate: z.string().optional(),\n  notes: z.string().optional(),\n})\n\n// Helper to get user from session or x-user-id header\nasync function getUserFromRequest(request: NextRequest): Promise<{ id: string; role: string; businessId: string | null } | null> {\n  // Try NextAuth session first\n  const session = await getServerSession(authOptions)\n  if (session?.user) {\n    return {\n      id: session.user.id,\n      role: session.user.role,\n      businessId: session.user.businessId,\n    }\n  }\n  \n  // Fall back to x-user-id header (backward compatibility)\n  const userId = request.headers.get(\"x-user-id\")\n  if (userId) {\n    try {\n      let dbUser = await db.user.findUnique({\n        where: { id: userId },\n        include: { business: true },\n      })\n      \n      // If user doesn't exist, create a default user and business (for backward compatibility with mock users)\n      if (!dbUser) {\n        console.log(`[getUserFromRequest] User ${userId} not found, creating default user...`)\n        \n        // Try to find existing business for this user (by email pattern)\n        // This ensures consistency - if user was created before, use same business\n        let business = await db.business.findFirst({\n          where: { \n            email: `cafe-${userId}@example.com`,\n          },\n        })\n        \n        // If no business found, create a new one with unique email based on userId\n        if (!business) {\n          business = await db.business.create({\n            data: {\n              name: \"Green Café\",\n              type: \"CAFE\",\n              email: `cafe-${userId}@example.com`,\n            },\n          })\n          console.log(`[getUserFromRequest] Created new business: ${business.id} for user ${userId}`)\n        } else {\n          console.log(`[getUserFromRequest] Found existing business: ${business.id} for user ${userId}`)\n        }\n        \n        // Create user with STAFF role (default for mock users)\n        dbUser = await db.user.create({\n          data: {\n            id: userId,\n            email: `user-${userId}@example.com`,\n            password: \"$2a$10$dummy\", // Dummy hash - user won't login via NextAuth\n            role: \"STAFF\",\n            businessId: business.id,\n            name: \"Staff User\",\n          },\n          include: { business: true },\n        })\n        \n        console.log(`[getUserFromRequest] Created default user: ${dbUser.id} with businessId: ${business.id}`)\n      }\n      \n      if (dbUser) {\n        return {\n          id: dbUser.id,\n          role: dbUser.role,\n          businessId: dbUser.businessId,\n        }\n      }\n    } catch (error) {\n      console.error(`[getUserFromRequest] Database error looking up user ${userId}:`, error)\n    }\n  } else {\n    console.log(\"[getUserFromRequest] No x-user-id header provided\")\n  }\n  \n  return null\n}\n\n// GET - Fetch waste entries\nexport async function GET(request: NextRequest) {\n  try {\n    const user = await getUserFromRequest(request)\n\n    if (!user) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\n    }\n\n    // If user has no businessId, find or create a default business\n    // Use same email pattern as getUserFromRequest for consistency\n    if (!user.businessId) {\n      // Try to find existing business for this user (by email pattern)\n      let business = await db.business.findFirst({\n        where: { \n          email: `cafe-${user.id}@example.com`,\n        },\n      })\n      \n      // If no business found, create a new one with unique email based on userId\n      if (!business) {\n        business = await db.business.create({\n          data: {\n            name: \"Green Café\",\n            type: \"CAFE\",\n            email: `cafe-${user.id}@example.com`,\n          },\n        })\n        console.log(`[GET /api/waste] Created new business: ${business.id} for user ${user.id}`)\n      } else {\n        console.log(`[GET /api/waste] Found existing business: ${business.id} for user ${user.id}`)\n      }\n      \n      // Update user with businessId\n      await db.user.update({\n        where: { id: user.id },\n        data: { businessId: business.id },\n      })\n      \n      user.businessId = business.id\n    }\n\n    const { searchParams } = new URL(request.url)\n    const startDate = searchParams.get(\"startDate\")\n    const endDate = searchParams.get(\"endDate\")\n    const wasteType = searchParams.get(\"wasteType\")\n    const actionType = searchParams.get(\"actionType\")\n    const status = searchParams.get(\"status\")\n    const recent = searchParams.get(\"recent\") === \"true\" // Special flag for recent entries\n    const page = parseInt(searchParams.get(\"page\") || \"1\")\n    const limit = recent ? 50 : parseInt(searchParams.get(\"limit\") || \"50\") // Show all recent entries, not just 5\n    const skip = (page - 1) * limit\n\n    const where: any = {}\n\n    // Filter by business if user is not admin\n    if (user.role !== \"ADMIN\") {\n      where.businessId = user.businessId\n    } else {\n      const businessId = searchParams.get(\"businessId\")\n      if (businessId) {\n        where.businessId = businessId\n      }\n    }\n\n    if (startDate || endDate) {\n      where.date = {}\n      if (startDate) {\n        where.date.gte = new Date(startDate)\n      }\n      if (endDate) {\n        where.date.lte = new Date(endDate)\n      }\n    }\n\n    if (wasteType && wasteType !== \"all\") {\n      where.wasteType = wasteType\n    }\n\n    if (actionType && actionType !== \"all\") {\n      where.actionType = actionType\n    }\n\n    if (status && status !== \"all\") {\n      where.status = status\n    }\n\n    console.log(`[GET /api/waste] Querying with where clause:`, JSON.stringify(where, null, 2))\n    \n    let entries, total\n    try {\n      [entries, total] = await Promise.all([\n        db.wasteEntry.findMany({\n          where,\n          include: {\n            loggedBy: {\n              select: {\n                id: true,\n                name: true,\n                email: true,\n              },\n            },\n            business: {\n              select: {\n                id: true,\n                name: true,\n                type: true,\n              },\n            },\n          },\n          orderBy: recent ? {\n            createdAt: \"desc\",\n          } : {\n            date: \"desc\",\n          },\n          skip,\n          take: limit,\n        }),\n        db.wasteEntry.count({ where }),\n      ])\n      console.log(`[GET /api/waste] Found ${entries.length} entries (total: ${total})`)\n    } catch (dbError) {\n      console.error(\"[GET /api/waste] Database error:\", dbError)\n      const errorMessage = dbError instanceof Error ? dbError.message : String(dbError)\n      return NextResponse.json(\n        { \n          error: \"Database error\", \n          message: errorMessage,\n          details: process.env.NODE_ENV === \"development\" ? String(dbError) : undefined\n        },\n        { status: 500 }\n      )\n    }\n\n    // Transform to match /api/staff/waste format for compatibility\n    const typeMap: Record<string, string> = {\n      \"EDIBLE\": \"edible\",\n      \"COFFEE_GROUNDS\": \"coffee\",\n      \"ORGANIC\": \"organic\",\n      \"EXPIRED\": \"expired\",\n      \"RECYCLABLE\": \"recyclable\",\n      \"PLATE_WASTE\": \"plate_waste\",\n    }\n\n    const transformedEntries = entries.map((entry) => {\n      const wasteType = String(entry.wasteType)\n      const displayType = typeMap[wasteType] || wasteType.toLowerCase()\n      const status = String(entry.status).toLowerCase()\n      const assignedTo = entry.availableFor ? String(entry.availableFor).toLowerCase() : null\n      \n      return {\n        id: entry.id,\n        cafeId: entry.businessId,\n        type: displayType,\n        itemName: entry.subType || displayType || \"Unknown\",\n        quantity: entry.quantity,\n        expiryDate: entry.expiryDate ? entry.expiryDate.toISOString().split(\"T\")[0] : \"\",\n        status: status,\n        assignedTo: assignedTo,\n        actionType: entry.actionType, // Include actionType for ACTION column\n        wasteType: entry.wasteType, // Include wasteType for filtering\n        subType: entry.subType, // Include subType\n        destination: entry.destination, // Include destination\n        date: entry.date, // Include date\n        loggedByName: entry.loggedBy?.name || \"Staff\", // Include logged by name\n        createdAt: entry.createdAt.toISOString(),\n        updatedAt: entry.updatedAt.toISOString(),\n        notes: entry.notes || undefined,\n      }\n    })\n\n    // For recent entries, return simplified format matching /api/staff/waste\n    if (recent) {\n      return NextResponse.json({\n        entries: transformedEntries,\n        total: transformedEntries.length,\n      })\n    }\n\n    return NextResponse.json({\n      entries: transformedEntries,\n      pagination: {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil(total / limit),\n      },\n    })\n  } catch (error) {\n    console.error(\"[GET /api/waste] Error fetching waste entries:\", error)\n    const errorMessage = error instanceof Error ? error.message : String(error)\n    return NextResponse.json(\n      { \n        error: \"Failed to fetch waste entries\",\n        message: errorMessage,\n        entries: [], // Always return entries array even on error\n        total: 0,\n      },\n      { status: 500 }\n    )\n  }\n}\n\n// POST - Create new waste entry\nexport async function POST(request: NextRequest) {\n  try {\n    const user = await getUserFromRequest(request)\n\n    if (!user) {\n      console.error(\"[POST /api/waste] Unauthorized - no user found\")\n      return NextResponse.json({ error: \"Unauthorized - please log in again\" }, { status: 401 })\n    }\n    \n    console.log(\"[POST /api/waste] User authenticated:\", { id: user.id, role: user.role, businessId: user.businessId })\n\n    // Only STAFF (café) users can create waste entries\n    if (user.role !== \"STAFF\" && user.role !== \"ADMIN\") {\n      return NextResponse.json({ error: \"Only staff members can log waste\" }, { status: 403 })\n    }\n\n    // If user has no businessId, find or create a default business\n    // Use same email pattern as getUserFromRequest for consistency\n    if (!user.businessId) {\n      // Try to find existing business for this user (by email pattern)\n      let business = await db.business.findFirst({\n        where: { \n          email: `cafe-${user.id}@example.com`,\n        },\n      })\n      \n      // If no business found, create a new one with unique email based on userId\n      if (!business) {\n        business = await db.business.create({\n          data: {\n            name: \"Green Café\",\n            type: \"CAFE\",\n            email: `cafe-${user.id}@example.com`,\n          },\n        })\n        console.log(`[POST /api/waste] Created new business: ${business.id} for user ${user.id}`)\n      } else {\n        console.log(`[POST /api/waste] Found existing business: ${business.id} for user ${user.id}`)\n      }\n      \n      // Update user with businessId\n      await db.user.update({\n        where: { id: user.id },\n        data: { businessId: business.id },\n      })\n      \n      user.businessId = business.id\n    }\n\n    const body = await request.json()\n    const validatedData = wasteEntrySchema.parse(body)\n\n    // Determine status and availableFor based on waste type\n    // Rule: EDIBLE food → CHARITY only, all other types → FARMER only\n    // WasteEntry is the source of truth - all entries start with PENDING status\n    let status: \"PENDING\" | \"AVAILABLE\" | \"APPROVED\" | \"COMPLETED\" | \"DROPPED\" = \"PENDING\"\n    let availableFor: \"CHARITY\" | \"FARMER\" | null = null\n    \n    if (validatedData.actionType === \"DROPPED\") {\n      status = \"DROPPED\"\n    } else {\n      // Automatically assign based on waste type\n      if (validatedData.wasteType === \"EDIBLE\") {\n        // EDIBLE food goes to CHARITY only\n        availableFor = \"CHARITY\"\n        status = \"PENDING\"\n      } else {\n        // All other types (COFFEE_GROUNDS, ORGANIC, EXPIRED, RECYCLABLE, PLATE_WASTE) go to FARMER only\n        availableFor = \"FARMER\"\n        status = \"PENDING\"\n      }\n    }\n\n    // Validate required fields before creating\n    if (!user.businessId) {\n      console.error(\"[POST /api/waste] ERROR: user.businessId is null\")\n      return NextResponse.json(\n        { \n          error: \"Database error\", \n          message: \"Unable to associate waste entry with a business. Please try again.\" \n        },\n        { status: 500 }\n      )\n    }\n\n    if (!user.id) {\n      console.error(\"[POST /api/waste] ERROR: user.id is null\")\n      return NextResponse.json(\n        { \n          error: \"Database error\", \n          message: \"User ID is missing. Please log in again.\" \n        },\n        { status: 500 }\n      )\n    }\n\n    // Verify user exists in database\n    try {\n      const userExists = await db.user.findUnique({\n        where: { id: user.id },\n      })\n      if (!userExists) {\n        console.error(\"[POST /api/waste] ERROR: User does not exist in database:\", user.id)\n        return NextResponse.json(\n          { \n            error: \"Database error\", \n            message: \"User not found. Please log in again.\" \n          },\n          { status: 500 }\n        )\n      }\n    } catch (userCheckError) {\n      console.error(\"[POST /api/waste] ERROR checking user:\", userCheckError)\n    }\n\n    // Verify business exists in database\n    try {\n      const businessExists = await db.business.findUnique({\n        where: { id: user.businessId },\n      })\n      if (!businessExists) {\n        console.error(\"[POST /api/waste] ERROR: Business does not exist in database:\", user.businessId)\n        return NextResponse.json(\n          { \n            error: \"Database error\", \n            message: \"Business not found. Please contact support.\" \n          },\n          { status: 500 }\n        )\n      }\n    } catch (businessCheckError) {\n      console.error(\"[POST /api/waste] ERROR checking business:\", businessCheckError)\n    }\n\n    console.log(\"[POST /api/waste] BEFORE db.wasteEntry.create() - Data:\", {\n      wasteType: validatedData.wasteType,\n      quantity: validatedData.quantity,\n      actionType: validatedData.actionType,\n      status,\n      availableFor,\n      businessId: user.businessId,\n      loggedById: user.id,\n    })\n\n    let wasteEntry\n    try {\n      // Build data object - only include availableFor if it's not null\n      // Handle dates carefully for SQLite\n      let entryDate = new Date()\n      if (validatedData.date) {\n        try {\n          entryDate = new Date(validatedData.date)\n          if (isNaN(entryDate.getTime())) {\n            entryDate = new Date() // Fallback to now if invalid\n          }\n        } catch (e) {\n          entryDate = new Date() // Fallback to now if parsing fails\n        }\n      }\n\n      const wasteEntryData: any = {\n        date: entryDate,\n        wasteType: validatedData.wasteType,\n        quantity: validatedData.quantity,\n        actionType: validatedData.actionType,\n        status,\n        loggedById: user.id,\n        businessId: user.businessId,\n      }\n\n      // Add optional fields\n      if (validatedData.subType) {\n        wasteEntryData.subType = validatedData.subType\n      }\n      if (validatedData.destination) {\n        wasteEntryData.destination = validatedData.destination\n      }\n      if (validatedData.expiryDate) {\n        try {\n          const expiry = new Date(validatedData.expiryDate)\n          if (!isNaN(expiry.getTime())) {\n            wasteEntryData.expiryDate = expiry\n          }\n        } catch (e) {\n          console.warn(\"[POST /api/waste] Invalid expiry date, skipping:\", validatedData.expiryDate)\n        }\n      }\n      if (validatedData.notes) {\n        wasteEntryData.notes = validatedData.notes\n      }\n      // Only add availableFor if it's not null\n      if (availableFor) {\n        wasteEntryData.availableFor = availableFor\n      }\n\n      console.log(\"[POST /api/waste] Creating with data:\", JSON.stringify(wasteEntryData, null, 2))\n\n      wasteEntry = await db.wasteEntry.create({\n        data: wasteEntryData,\n      include: {\n        loggedBy: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          },\n        },\n        business: {\n          select: {\n            id: true,\n            name: true,\n            type: true,\n          },\n        },\n      },\n    })\n\n    console.log(\"[POST /api/waste] AFTER db.wasteEntry.create() - Success! Entry ID:\", wasteEntry.id)\n    console.log(\"[POST /api/waste] Created entry details:\", {\n      id: wasteEntry.id,\n      wasteType: wasteEntry.wasteType,\n      subType: wasteEntry.subType,\n      quantity: wasteEntry.quantity,\n      actionType: wasteEntry.actionType,\n      status: wasteEntry.status,\n      availableFor: wasteEntry.availableFor,\n      businessId: wasteEntry.businessId,\n    })\n\n    // Award points based on action type (don't fail if this doesn't work)\n    try {\n      let points = 0\n      if (validatedData.actionType === \"DONATE\") {\n        points = Math.floor(validatedData.quantity) // 1 point per kg donated\n      } else if (validatedData.actionType === \"COMPOST\" || validatedData.actionType === \"FARM\") {\n        points = Math.floor(validatedData.quantity * 0.5) // 0.5 points per kg composted\n      } else if (validatedData.actionType === \"REUSE\") {\n        points = Math.floor(validatedData.quantity * 0.8) // 0.8 points per kg reused\n      }\n\n      if (points > 0) {\n        await db.pointsHistory.create({\n          data: {\n            userId: user.id,\n            wasteEntryId: wasteEntry.id,\n            points,\n            reason: `Logged ${validatedData.quantity} kg of ${validatedData.wasteType.toLowerCase()} - ${validatedData.actionType.toLowerCase()}`,\n          },\n        })\n        console.log(\"[POST /api/waste] Points awarded:\", points)\n      }\n    } catch (pointsError) {\n      // Don't fail the entire request if points creation fails\n      console.error(\"[POST /api/waste] Failed to create points history (non-critical):\", pointsError)\n    }\n\n    return NextResponse.json(wasteEntry, { status: 201 })\n    } catch (dbError) {\n      console.error(\"[POST /api/waste] Database error during create:\", dbError)\n      console.error(\"[POST /api/waste] Error details:\", {\n        message: dbError instanceof Error ? dbError.message : String(dbError),\n        stack: dbError instanceof Error ? dbError.stack : undefined,\n        name: dbError instanceof Error ? dbError.name : undefined,\n      })\n      \n      const errorMessage = dbError instanceof Error ? dbError.message : String(dbError)\n      \n      // Check for specific database errors\n      let userFriendlyMessage = \"Failed to create waste entry\"\n      if (errorMessage.includes(\"Foreign key constraint\") || errorMessage.includes(\"foreign key\")) {\n        userFriendlyMessage = \"Invalid user or business. Please log in again.\"\n      } else if (errorMessage.includes(\"NOT NULL constraint\") || errorMessage.includes(\"null\")) {\n        userFriendlyMessage = \"Missing required information. Please fill in all fields.\"\n      } else if (errorMessage.includes(\"SQLite\") || errorMessage.includes(\"database\")) {\n        userFriendlyMessage = \"Database error. Please try again.\"\n      }\n      \n      return NextResponse.json(\n        { \n          error: \"Database error\", \n          message: userFriendlyMessage,\n          details: process.env.NODE_ENV === \"development\" ? errorMessage : undefined\n        },\n        { status: 500 }\n      )\n    }\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json({ error: \"Invalid input data\", details: error.errors }, { status: 400 })\n    }\n\n    console.error(\"[POST /api/waste] Error creating waste entry:\", error)\n    const errorMessage = error instanceof Error ? error.message : String(error)\n    return NextResponse.json(\n      { \n        error: \"Failed to create waste entry\", \n        message: errorMessage,\n        details: process.env.NODE_ENV === \"development\" ? String(error) : undefined\n      },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}}]
}