{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///D:/CS%20Y3/FYP/FWMS/FWMS/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\"\n\n/**\n * Database client singleton.\n * Prevents creating multiple Prisma clients during development hot-reloads.\n */\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\n// Create or reuse existing Prisma client\nexport const db =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    // Log queries in development for debugging\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  })\n\n// Store in global to reuse across hot-reloads (development only)\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = db\n\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;CAGC,GACD,MAAM,kBAAkB;AAKjB,MAAM,KACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,2CAA2C;IAC3C,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEF,iEAAiE;AACjE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///D:/CS%20Y3/FYP/FWMS/FWMS/app/api/marketplace/waste/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { db } from \"@/lib/db\"\n\n// GET /api/marketplace/waste\n// Returns available waste entries for the logged-in user based on their role.\n// - Filters by status = PENDING\n// - Filters by availableFor matching user's role (CHARITY or FARMER)\n// - Shows waste from all businesses\nexport async function GET(request: NextRequest) {\n  try {\n    // Get user ID from header\n    const userId = request.headers.get(\"x-user-id\")\n    if (!userId) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\n    }\n\n    // Find user in database\n    let user = await db.user.findUnique({\n      where: { id: userId },\n      include: { business: true },\n    })\n\n    // If user doesn't exist and it's a demo charity user, create a temporary one\n    if (!user && (userId.includes(\"charity\") || userId === \"u-charity-1\")) {\n      console.log(`[Marketplace] Demo charity user ${userId} not found, allowing access for public portal`)\n      // For demo purposes, allow access without creating a user\n      // The filtering will work based on userId pattern\n      user = {\n        id: userId,\n        role: \"PARTNER\",\n        business: null,\n      } as any\n    } else if (!user) {\n      return NextResponse.json({ error: \"User not found\" }, { status: 404 })\n    }\n\n    // Determine availableFor based on user's business type\n    let availableFor: \"CHARITY\" | \"FARMER\" | null = null\n    if (user.business?.type === \"NGO\") {\n      availableFor = \"CHARITY\"\n    } else if (user.business?.type === \"FARM\") {\n      availableFor = \"FARMER\"\n    } else {\n      // Fallback: Check if user ID matches charity/farmer pattern (for demo/testing)\n      // Or check user role - PARTNER users might be charity or farmer\n      if (userId.includes(\"charity\") || userId.includes(\"ngo\")) {\n        // Demo fallback: if userId contains \"charity\" or \"ngo\", treat as charity\n        console.log(`[Marketplace] User ${userId} matches charity pattern, defaulting to CHARITY`)\n        availableFor = \"CHARITY\"\n      } else if (userId.includes(\"farmer\") || userId.includes(\"farm\")) {\n        // Demo fallback: if userId contains \"farmer\" or \"farm\", treat as farmer\n        console.log(`[Marketplace] User ${userId} matches farmer pattern, defaulting to FARMER`)\n        availableFor = \"FARMER\"\n      } else if (user.role === \"PARTNER\" && !user.business) {\n        // If user is PARTNER but no business, check userId pattern\n        if (userId.includes(\"charity\") || userId.includes(\"ngo\")) {\n          availableFor = \"CHARITY\"\n        } else {\n          availableFor = \"FARMER\"\n        }\n        console.log(`[Marketplace] User ${userId} is PARTNER without business, defaulting to ${availableFor}`)\n      } else {\n        console.log(`[Marketplace] User ${userId} has business type: ${user.business?.type || \"null\"}, role: ${user.role}, cannot access marketplace`)\n        return NextResponse.json(\n          { \n            error: \"Only charity and farmer users can access marketplace\",\n            details: `Your business type is: ${user.business?.type || \"not set\"}. Please register as a FARM or NGO business.`\n          },\n          { status: 403 }\n        )\n      }\n    }\n\n    console.log(`[Marketplace] User ${userId} (business type: ${user.business?.type || \"none\"}, role: ${user.role}) looking for items with availableFor: ${availableFor}`)\n\n    // Get all waste entries that are PENDING and match the user's role\n    // Exclude items that already have active pickup requests\n    const activeRequestWasteIds = await db.pickupRequest.findMany({\n      where: {\n        status: {\n          in: [\"PENDING\", \"APPROVED\"],\n        },\n      },\n      select: {\n        wasteEntryId: true,\n      },\n    })\n\n    const requestedWasteIds = new Set(\n      activeRequestWasteIds\n        .map((r) => r.wasteEntryId)\n        .filter((id): id is string => id !== null)\n    )\n\n    console.log(`[Marketplace] Found ${requestedWasteIds.size} waste items with active pickup requests (excluded from results)`)\n\n    // Debug: Check all waste entries to see what's available\n    const allWasteEntries = await db.wasteEntry.findMany({\n      select: {\n        id: true,\n        status: true,\n        availableFor: true,\n        wasteType: true,\n        subType: true,\n        quantity: true,\n      },\n      take: 20, // Get more entries for debugging\n      orderBy: {\n        createdAt: \"desc\",\n      },\n    })\n    console.log(`[Marketplace] Recent waste entries in DB (${allWasteEntries.length}):`, allWasteEntries.map(e => ({\n      id: e.id,\n      status: e.status,\n      availableFor: e.availableFor,\n      wasteType: e.wasteType,\n      subType: e.subType,\n      quantity: e.quantity,\n    })))\n\n    // Build where clause with wasteType-based filtering\n    // Rule: EDIBLE → CHARITY only, all other types → FARMER only\n    // Only show items that are PENDING and not DROPPED\n    \n    // Prepare expiry date filter\n    const today = new Date()\n    today.setHours(0, 0, 0, 0) // Start of today\n    \n    // Build base where clause\n    // All conditions are ANDed together by default in Prisma\n    const whereClause: any = {\n      status: \"PENDING\",\n      id: {\n        notIn: Array.from(requestedWasteIds),\n      },\n      // Explicitly exclude dropped items\n      actionType: {\n        not: \"DROPPED\",\n      },\n      // Expiry date filter - show items that haven't expired yet\n      // If expiryDate is null, show it (no expiry means it's still good)\n      // If expiryDate exists, only show if it's today or in the future\n      AND: [\n        {\n          OR: [\n            { expiryDate: null },\n            { expiryDate: { gte: today } },\n          ],\n        },\n      ],\n    }\n    \n    // Add wasteType and availableFor filters based on user type\n    // This is the primary filter - wasteType determines who can see it\n    if (availableFor === \"CHARITY\") {\n      // Charity users only see EDIBLE items\n      whereClause.wasteType = \"EDIBLE\"\n      // Filter by availableFor - allow both explicit CHARITY and null (for legacy/inferred records)\n      // Since wasteType=EDIBLE implies CHARITY, we accept null availableFor\n      whereClause.AND.push({\n        OR: [\n          { availableFor: \"CHARITY\" },\n          { availableFor: null },\n        ],\n      })\n    } else if (availableFor === \"FARMER\") {\n      // Farmer users see all types EXCEPT EDIBLE\n      whereClause.wasteType = {\n        not: \"EDIBLE\"\n      }\n      // Filter by availableFor - allow both explicit FARMER and null (for legacy/inferred records)\n      whereClause.AND.push({\n        OR: [\n          { availableFor: \"FARMER\" },\n          { availableFor: null },\n        ],\n      })\n    }\n    \n    console.log(`[Marketplace] Querying with where clause:`, JSON.stringify(whereClause, null, 2))\n    console.log(`[Marketplace] Looking for items with wasteType=${availableFor === \"CHARITY\" ? \"EDIBLE\" : \"NOT EDIBLE\"} AND (availableFor=${availableFor} OR availableFor=null)`)\n\n    // First, let's do a simple test query to verify database connection\n    const testQuery = await db.wasteEntry.findFirst({\n      where: {\n        wasteType: \"EDIBLE\",\n        status: \"PENDING\",\n      },\n      select: {\n        id: true,\n        subType: true,\n        status: true,\n        availableFor: true,\n        wasteType: true,\n        actionType: true,\n        expiryDate: true,\n      },\n    })\n    console.log(`[Marketplace] Test query - Found one EDIBLE PENDING entry:`, testQuery)\n\n    const wasteEntries = await db.wasteEntry.findMany({\n      where: whereClause,\n      include: {\n        business: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n            phone: true,\n            address: true,\n            contactPerson: true,\n            type: true,\n          },\n        },\n        loggedBy: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          },\n        },\n      },\n      orderBy: {\n        createdAt: \"desc\", // Use createdAt instead of date for more reliable sorting\n      },\n    })\n\n    console.log(`[Marketplace] Found ${wasteEntries.length} waste entries matching filter criteria`)\n    \n    // Log details of found entries for debugging\n    if (wasteEntries.length > 0) {\n      console.log(`[Marketplace] Sample entries found:`, wasteEntries.slice(0, 3).map(e => ({\n        id: e.id,\n        subType: e.subType,\n        wasteType: e.wasteType,\n        status: e.status,\n        availableFor: e.availableFor,\n        actionType: e.actionType,\n        quantity: e.quantity,\n        expiryDate: e.expiryDate,\n      })))\n    } else {\n      console.log(`[Marketplace] No entries found. Checking if any matching entries exist...`)\n      // Debug query - check if any entries exist with the expected criteria\n      const debugQuery = {\n        wasteType: availableFor === \"CHARITY\" ? \"EDIBLE\" : { not: \"EDIBLE\" },\n        availableFor: availableFor,\n        status: \"PENDING\",\n      }\n      console.log(`[Marketplace] Debug query:`, JSON.stringify(debugQuery, null, 2))\n      \n      const debugEntries = await db.wasteEntry.findMany({\n        where: debugQuery,\n        select: {\n          id: true,\n          subType: true,\n          status: true,\n          availableFor: true,\n          wasteType: true,\n          expiryDate: true,\n          actionType: true,\n        },\n        take: 10,\n        orderBy: {\n          createdAt: \"desc\",\n        },\n      })\n      console.log(`[Marketplace] Debug entries matching criteria:`, debugEntries)\n      \n      // Also check all EDIBLE entries regardless of availableFor\n      if (availableFor === \"CHARITY\") {\n        const allEdible = await db.wasteEntry.findMany({\n          where: {\n            wasteType: \"EDIBLE\",\n            status: \"PENDING\",\n          },\n          select: {\n            id: true,\n            subType: true,\n            status: true,\n            availableFor: true,\n            expiryDate: true,\n            actionType: true,\n          },\n          take: 10,\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        })\n        console.log(`[Marketplace] All PENDING EDIBLE entries in DB (regardless of availableFor):`, allEdible)\n      }\n    }\n\n    // Transform to match expected format\n    const mappedItems = wasteEntries.map((entry) => ({\n      id: entry.id,\n      cafeId: entry.businessId,\n      cafeName: entry.business.name || \"Unknown Café\",\n      itemName: entry.subType || entry.wasteType,\n      type: entry.wasteType.toLowerCase(),\n      quantity: entry.quantity,\n      expiryDate: entry.expiryDate?.toISOString().split(\"T\")[0] || \"\",\n      status: entry.status.toLowerCase(),\n      description: entry.notes || undefined,\n      createdAt: entry.createdAt.toISOString(), // Include createdAt for notification tracking\n      // Compute effective availableFor from wasteType to correct legacy data\n      availableFor: entry.wasteType === \"EDIBLE\" ? \"CHARITY\" : \"FARMER\",\n      business: {\n        id: entry.businessId,\n        name: entry.business.name || \"Unknown Café\",\n        type: entry.business.type,\n        address: entry.business.address,\n      },\n      cafeContact: {\n        name: entry.business.contactPerson || entry.loggedBy.name || \"Café Admin\",\n        email: entry.business.email || entry.loggedBy.email || null,\n        organizationName: entry.business.name || \"Unknown Café\",\n        phone: entry.business.phone || null,\n        address: entry.business.address || null,\n      },\n    }))\n\n    console.log(`[Marketplace] Returning ${mappedItems.length} items for ${availableFor}`)\n    console.log(`[Marketplace] Mapped items details:`, mappedItems.map(item => ({\n      id: item.id,\n      itemName: item.itemName,\n      wasteType: item.type,\n      availableFor: item.availableFor,\n      status: item.status,\n      expiryDate: item.expiryDate,\n    })))\n\n    // Filter out any mismatched legacy records just in case\n    const filteredItems = mappedItems.filter((item) => {\n      if (availableFor === \"CHARITY\") {\n        return item.availableFor === \"CHARITY\"\n      }\n      if (availableFor === \"FARMER\") {\n        return item.availableFor === \"FARMER\"\n      }\n      return false\n    })\n\n    console.log(`[Marketplace] Final filtered items count: ${filteredItems.length} (after filtering by availableFor)`)\n    if (filteredItems.length !== mappedItems.length) {\n      console.log(`[Marketplace] Filtered out ${mappedItems.length - filteredItems.length} items due to availableFor mismatch`)\n    }\n\n    return NextResponse.json(filteredItems)\n  } catch (error) {\n    console.error(\"[Marketplace Waste] Error:\", error)\n    return NextResponse.json(\n      { error: \"Failed to fetch marketplace waste\" },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}