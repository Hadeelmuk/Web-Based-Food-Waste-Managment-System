{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///D:/CS%20Y3/FYP/FWMS/FWMS/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\"\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: PrismaClient | undefined\r\n}\r\n\r\nexport const db =\r\n  globalForPrisma.prisma ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\r\n  })\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = db\r\n\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,KACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEF,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///D:/CS%20Y3/FYP/FWMS/FWMS/app/api/farmer/available/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\r\nimport { db } from \"@/lib/db\"\r\n\r\ntype AvailableItem = {\r\n  id: string\r\n  cafeId: string\r\n  cafeName: string\r\n  itemName: string\r\n  type: string\r\n  quantity: number\r\n  expiryDate: string\r\n  status: string\r\n}\r\n\r\n// GET /api/farmer/available\r\n// Lists organic/coffee waste items that are pending and available for farms.\r\n// Uses database instead of in-memory arrays.\r\n// Public endpoint - no authentication required\r\nexport async function GET(req: NextRequest) {\r\n  try {\r\n    // Try to use database first, fallback to in-memory if database fails\r\n    try {\r\n      // Get all waste entry IDs that have active pickup requests (pending or approved)\r\n      const activeRequests = await db.pickupRequest.findMany({\r\n        where: {\r\n          status: {\r\n            in: [\"PENDING\", \"APPROVED\"],\r\n          },\r\n        },\r\n        select: {\r\n          wasteEntryId: true,\r\n        },\r\n      })\r\n\r\n      const requestedWasteIds = new Set(\r\n        activeRequests\r\n          .map((r) => r.wasteEntryId)\r\n          .filter((id): id is string => id !== null)\r\n      )\r\n\r\n      // Fetch waste entries from database\r\n      // Filter for organic/coffee waste that is pending and not requested\r\n      const wasteEntries = await db.wasteEntry.findMany({\r\n        where: {\r\n          wasteType: {\r\n            in: [\"ORGANIC\", \"COFFEE_GROUNDS\"],\r\n          },\r\n          status: \"PENDING\",\r\n          id: {\r\n            notIn: Array.from(requestedWasteIds),\r\n          },\r\n          // Don't show expired items\r\n          OR: [\r\n            { expiryDate: null },\r\n            { expiryDate: { gte: new Date() } },\r\n          ],\r\n        },\r\n        include: {\r\n          business: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          date: \"desc\",\r\n        },\r\n      })\r\n\r\n      // Transform database entries to match expected format\r\n      const items: AvailableItem[] = wasteEntries.map((entry) => {\r\n        // Map database wasteType to simple type string\r\n        const typeMap: Record<string, string> = {\r\n          ORGANIC: \"organic\",\r\n          COFFEE_GROUNDS: \"coffee\",\r\n          EDIBLE: \"edible\",\r\n        }\r\n\r\n        return {\r\n          id: entry.id,\r\n          cafeId: entry.businessId,\r\n          cafeName: entry.business.name || \"Green Café\",\r\n          itemName: entry.subType || typeMap[entry.wasteType] || entry.wasteType.toLowerCase(),\r\n          type: typeMap[entry.wasteType] || entry.wasteType.toLowerCase(),\r\n          quantity: entry.quantity,\r\n          expiryDate: entry.expiryDate ? entry.expiryDate.toISOString().split(\"T\")[0] : \"\",\r\n          status: entry.status.toLowerCase(),\r\n        }\r\n      })\r\n\r\n      console.log(`[Farmer Available] Returning ${items.length} items from database`)\r\n      return NextResponse.json(items)\r\n    } catch (dbError) {\r\n      // If database fails, fallback to in-memory arrays\r\n      console.warn(\"[Farmer Available] Database error, falling back to in-memory:\", dbError)\r\n      const { wasteLogs, pickupRequests, users } = await import(\"@/app/api/_data\")\r\n      \r\n      const requestedWasteIds = new Set(\r\n        pickupRequests\r\n          .filter((p) => p.status === \"pending\" || p.status === \"approved\")\r\n          .map((p) => p.wasteId)\r\n      )\r\n\r\n      const items: AvailableItem[] = wasteLogs\r\n        .filter(\r\n          (w) =>\r\n            (w.type === \"organic\" || w.type === \"coffee\") &&\r\n            w.status === \"pending\" &&\r\n            w.assignedTo === \"farmer\" &&\r\n            !requestedWasteIds.has(w.id)\r\n        )\r\n        .map((w) => {\r\n          const cafeUser = users.find((u) => u.cafeId === w.cafeId)\r\n          return {\r\n            id: w.id,\r\n            cafeId: w.cafeId,\r\n            cafeName: cafeUser?.organizationName || \"Green Café\",\r\n            itemName: w.itemName,\r\n            type: w.type,\r\n            quantity: w.quantity,\r\n            expiryDate: w.expiryDate,\r\n            status: w.status,\r\n          }\r\n        })\r\n\r\n      return NextResponse.json(items)\r\n    }\r\n  } catch (error) {\r\n    console.error(\"[Farmer Available] Error:\", error)\r\n    // Return empty array instead of error to prevent frontend crashes\r\n    return NextResponse.json([])\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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","debugId":null}}]
}